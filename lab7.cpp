// Подключаем библиотеки
#include <cstdlib> // Работа с памятью, процесс выполнения программы
#include <iostream> // Поточного вывода/вывода
#include <math.h> // Математические функции
// Подключаем пространства имен
using namespace std;
/*Решение нелинейного уравнения методами:
1) половинного деления,
2) Ньютона (касательных),
3) итераций
с точностью 0.000001 на отрезке [0;2].*/

float eps = 0.000001;

//вычисление значения функции f(x)
float f(float x)
{
	return(x * sqrt(x + 1.0) - 1.5);
}

//метод половинного деления
void PolovDel(float a1, float b1)
{
	cout << "Решение методом половинного деления:" << endl;
	float c = 0;
	while (abs(b1 - a1) > eps)
	{

		c = (a1 + b1) / 2.0;
		if (f(a1) * f(c) < 0)
		{
			b1 = c;
		}
		else
		{
			a1 = c;
		}
	}
	cout << "Корень уравнения на отрезке [0; 2] равен: " << c << endl << endl;
}

//функция вычисления значения первой производной
float Proizv_f(float x)
{
	return(sqrt(x + 1.0) + x / (2.0 * sqrt(x + 1.0)));
}

//функция вычисления значения второй производной
float Proizv2_f(float x)
{
	return(1.0 / (2.0 * sqrt(x + 1.0)) + (2.0 * sqrt(x + 1.0) - x / (sqrt(x + 1.0))) / (4.0 * (x + 1.0)));
}

//вычисление значения функции фи
float fi(float x)
{
	return(1.5 / (sqrt(x + 1.0)));
}

//метод Ньютона
void Nuton(float a, float b)
{
	cout << "Решение методом Ньютона (касательных):" << endl;
	float x0;
	if (f(a) * Proizv2_f(a) > 0)  //выбираем начальное приближение х0
	{
		x0 = a;
	}
	else
	{
		x0 = b;
	}
	float xn = 0;
	float z = 0;
	float xnp1 = x0;  //пишем число побольше, чтобы зайти в цикл
	while (abs(xnp1 - xn) > eps) //крутимся в цикле до тех пор, пока не достигнем требуемой точности
	{
		xn = xnp1;							//сохраняем значение на предыдущей итерации, оно становится xn
		xnp1 = xn - f(xn) / Proizv_f(xn);   //вычисляем новое значение xnp1
	}
	cout << "Корень уравнения на отрезке [0; 2] равен: " << xnp1 << endl << endl;
}

//метод Итераций
void Iteracii(float a, float b)
{
	cout << "Решение методом итераций:" << endl;
	float x0 = a;  //за начальное приближение берем левый конец отрезка
	float xnp1 = x0;
	float xn = 1; //взяли число побольше, чтобы зайти в цикл
	while (abs(xnp1 - xn) > eps)  //крутимся в цикле до тех пор, пока не достигнем требуемой точности
	{
		xn = xnp1;                //сохраняем значение на предыдущей итерации, оно становится xn
		xnp1 = fi(xn);            //вычисляем новое значение xnp1
	}
	cout << "Корень уравнения на отрезке [0; 2] равен: " << xnp1 << endl << endl;
}

void main()
{
	setlocale(LC_ALL, "russian"); // чтобы на консоли отображались русские буквы
	float a = 0, b = 2; //границы отрезка, на котором надо искать корень
	PolovDel(a, b);
	Nuton(a, b);
	Iteracii(a, b);
	system("pause");
}
